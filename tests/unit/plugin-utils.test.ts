import { jest, describe, it, expect } from '@jest/globals';

describe('Plugin Utility Functions', () => {
  describe('File Name Sanitization', () => {
    it('should remove special characters from file names', () => {
      const sanitizeFileName = (fileName: string) => {
        return fileName.replace(/[<>:"/\\|?*]/g, "-").replace(/\s+/g, "-");
      };

      expect(sanitizeFileName('test/file:name')).toBe('test-file-name');
      expect(sanitizeFileName('file with spaces')).toBe('file-with-spaces');
      expect(sanitizeFileName('special*chars?here')).toBe('special-chars-here');
      expect(sanitizeFileName('normal-file')).toBe('normal-file');
    });
  });

  describe('Sort Order Description', () => {
    it('should return correct descriptions for sort orders', () => {
      const getSortOrderDescription = (tag: string, sortOrder: string, customOrder: Record<string, string[]>) => {
        if (sortOrder === "custom" && customOrder[tag]) {
          return "Custom Order";
        }
        
        switch (sortOrder) {
          case "title":
            return "Alphabetical (Title)";
          case "modified":
            return "Last Modified";
          case "created":
            return "Created Date";
          case "custom":
            return "Default Order";
          default:
            return "Unknown";
        }
      };

      expect(getSortOrderDescription('test', 'title', {})).toBe('Alphabetical (Title)');
      expect(getSortOrderDescription('test', 'modified', {})).toBe('Last Modified');
      expect(getSortOrderDescription('test', 'created', {})).toBe('Created Date');
      expect(getSortOrderDescription('test', 'custom', { test: ['note1.md'] })).toBe('Custom Order');
      expect(getSortOrderDescription('test', 'custom', {})).toBe('Default Order');
      expect(getSortOrderDescription('test', 'unknown', {})).toBe('Unknown');
    });
  });

  describe('Tag Note Content Generation', () => {
    it('should generate properly formatted tag note content', () => {
      const generateTagNoteContent = (tag: string, notes: any[]) => {
        const timestamp = new Date().toISOString();
        let content = `---
tag: ${tag}
generated: ${timestamp}
total_notes: ${notes.length}
sort_order: custom
---

# Tag Navigator: #${tag}

Generated on: ${new Date().toLocaleDateString()}
Sort Order: Custom Order
Total Notes: ${notes.length}

## Notes List

`;

        notes.forEach((note, index) => {
          content += `${index + 1}. [[${note.title}]]\n`;
        });

        content += `
---
*This note was automatically generated by Tag Navigator plugin*
`;

        return content;
      };

      const testNotes = [
        { title: 'Note 1' },
        { title: 'Note 2' }
      ];

      const content = generateTagNoteContent('research', testNotes);

      expect(content).toContain('# Tag Navigator: #research');
      expect(content).toContain('Total Notes: 2');
      expect(content).toContain('1. [[Note 1]]');
      expect(content).toContain('2. [[Note 2]]');
      expect(content).toContain('*This note was automatically generated by Tag Navigator plugin*');
    });
  });

  describe('Array Sorting Utilities', () => {
    it('should sort notes by title', () => {
      const notes = [
        { title: 'C Note', file: { stat: { mtime: 1000 } } },
        { title: 'A Note', file: { stat: { mtime: 2000 } } },
        { title: 'B Note', file: { stat: { mtime: 3000 } } }
      ];

      const sorted = notes.sort((a, b) => a.title.localeCompare(b.title));
      expect(sorted.map(n => n.title)).toEqual(['A Note', 'B Note', 'C Note']);
    });

    it('should sort notes by modified time', () => {
      const notes = [
        { title: 'First', file: { stat: { mtime: 1000 } } },
        { title: 'Second', file: { stat: { mtime: 3000 } } },
        { title: 'Third', file: { stat: { mtime: 2000 } } }
      ];

      const sorted = notes.sort((a, b) => b.file.stat.mtime - a.file.stat.mtime);
      expect(sorted.map(n => n.title)).toEqual(['Second', 'Third', 'First']);
    });

    it('should sort notes by custom order', () => {
      const notes = [
        { title: 'First', file: { path: 'first.md' } },
        { title: 'Second', file: { path: 'second.md' } },
        { title: 'Third', file: { path: 'third.md' } }
      ];

      const customOrder = ['third.md', 'first.md', 'second.md'];
      
      const sorted = notes.sort((a, b) => {
        const aIndex = customOrder.indexOf(a.file.path);
        const bIndex = customOrder.indexOf(b.file.path);
        
        if (aIndex === -1 && bIndex === -1) return 0;
        if (aIndex === -1) return 1;
        if (bIndex === -1) return -1;
        
        return aIndex - bIndex;
      });

      expect(sorted.map(n => n.title)).toEqual(['Third', 'First', 'Second']);
    });
  });

  describe('Tag Processing', () => {
    it('should extract and clean tags', () => {
      const extractTags = (tagData: any[]) => {
        return tagData.map(tag => tag.tag.replace('#', ''));
      };

      const tagData = [
        { tag: '#research' },
        { tag: '#important' },
        { tag: '#project' }
      ];

      const cleanTags = extractTags(tagData);
      expect(cleanTags).toEqual(['research', 'important', 'project']);
    });

    it('should get unique tags from multiple notes', () => {
      const getUniqueTags = (notes: any[]) => {
        const tagSet = new Set<string>();
        
        for (const note of notes) {
          for (const tag of note.tags) {
            tagSet.add(tag);
          }
        }
        
        return Array.from(tagSet).sort();
      };

      const notes = [
        { tags: ['research', 'important'] },
        { tags: ['research', 'project'] },
        { tags: ['project', 'work'] }
      ];

      const uniqueTags = getUniqueTags(notes);
      expect(uniqueTags).toEqual(['important', 'project', 'research', 'work']);
    });
  });

  describe('Navigation Logic', () => {
    it('should calculate next index with wrap-around', () => {
      const getNextIndex = (currentIndex: number, arrayLength: number) => {
        return (currentIndex + 1) % arrayLength;
      };

      expect(getNextIndex(0, 3)).toBe(1);
      expect(getNextIndex(1, 3)).toBe(2);
      expect(getNextIndex(2, 3)).toBe(0); // wrap around
    });

    it('should calculate previous index with wrap-around', () => {
      const getPrevIndex = (currentIndex: number, arrayLength: number) => {
        return currentIndex === 0 ? arrayLength - 1 : currentIndex - 1;
      };

      expect(getPrevIndex(2, 3)).toBe(1);
      expect(getPrevIndex(1, 3)).toBe(0);
      expect(getPrevIndex(0, 3)).toBe(2); // wrap around
    });
  });
}); 